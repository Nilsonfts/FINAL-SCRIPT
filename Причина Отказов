/*******************************************************************************
 * * НАСТРОЙКИ СКРИПТА
 * *******************************************************************************/
const CONFIG = {
  // Модели: основная и запасная
  GPT_PRIMARY_MODEL:   'gpt-4o',
  GPT_FALLBACK_MODEL:  'gpt-4o-mini',

  // Ограничения для сжатия промпта
  MAX_REASON_CLUSTERS:    70,
  MAX_EXAMPLES_PER_CAUSE: 4,
  MAX_PROMPT_CHARS:       10000,
  
  // Количество ТОП-причин для гистограммы
  TOP_N_FOR_STACKED_CHART: 5,

  // Названия листов и часовой пояс
  SOURCE_SHEET: 'РАБОЧИЙ АМО',
  OUTPUT_SHEET: 'Причина отказов',
  TIMEZONE:     'Europe/Moscow',
  
  // Настройки для форматирования колонок
  COLUMN_WIDTHS: {
    A: 40, B: 350, C: 80,
  }
};


/**
 * Главная функция: анализ отказов по статусу «Закрыто и не реализовано»
 */
function dailyReportWithGPT(){
  const OPENAI_API_KEY = PropertiesService.getScriptProperties().getProperty('OPENAI_API_KEY');
  if (!OPENAI_API_KEY) {
    throw new Error('Ключ "OPENAI_API_KEY" не найден в Свойствах скрипта. Пожалуйста, добавьте его.');
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName(CONFIG.SOURCE_SHEET);
  if (!sh) throw new Error(`Лист «${CONFIG.SOURCE_SHEET}» не найден`);

  const {header, rows} = readTable_(sh);
  const i = detectAmoIndexes_(header);
  assertIndexes_(i, ['status','reason','created']);

  const items = rows.map(r=>({
    status:  norm_(r[i.status]),
    reason:  str(r[i.reason]),
    created: toDate_(r[i.created])
  }))
  .filter(x => isClosedLost_(x.status) && x.reason && x.created);

  const reasonsTable = calculateFrequency_(items.map(x=>x.reason));
  const monthlyTotal = calculateMonthlyBreakdown_(items);
  const monthlyReasons = calculateMonthlyReasonBreakdown_(items, reasonsTable);
  
  const compact = compactReasons_(items.map(x=>x.reason));
  const pieBlob = createPieChartImage_(compact);

  let prompt = buildDetailedAnalysisPrompt_(compact, items.length);
  if (prompt.length > CONFIG.MAX_PROMPT_CHARS) prompt = prompt.slice(0, CONFIG.MAX_PROMPT_CHARS);

  let gptText;
  try {
    gptText = callGPT_(OPENAI_API_KEY, prompt, CONFIG.GPT_PRIMARY_MODEL);
  } catch (e) {
    if (String(e).includes('429') || String(e).toLowerCase().includes('rate_limit')) {
      gptText = callGPT_(OPENAI_API_KEY, prompt, CONFIG.GPT_FALLBACK_MODEL);
    } else {
      throw e;
    }
  }

  writeOutSheet_(ss, reasonsTable, monthlyTotal, items.length, gptText, pieBlob, monthlyReasons);

  const subject = `📊 Анализ ${items.length} отказов (AMO) • ${Utilities.formatDate(new Date(), CONFIG.TIMEZONE, 'dd.MM.yyyy')}`;
  const htmlBody = formatReportAsHtml_(subject, gptText, monthlyTotal, 'pieChart');
  MailApp.sendEmail({
    to: Session.getActiveUser().getEmail(),
    subject,
    htmlBody,
    inlineImages: { pieChart: pieBlob }
  });
}

/** Создать ежедневный триггер */
function createTriggerDaily_(){
  ScriptApp.getProjectTriggers()
    .filter(t=>t.getHandlerFunction()==='dailyReportWithGPT')
    .forEach(t=>ScriptApp.deleteTrigger(t));
  ScriptApp.newTrigger('dailyReportWithGPT').timeBased().atHour(9).everyDays(1).inTimezone(CONFIG.TIMEZONE).create();
  SpreadsheetApp.getUi().alert('Ежедневный триггер для анализа отказов успешно создан!');
}


/* ==================== ВЫВОД НА ЛИСТ ==================== */

function writeOutSheet_(ss, reasonsTable, monthly, total, gpt, pieBlob, monthlyReasons){
  const sh = ss.getSheetByName(CONFIG.OUTPUT_SHEET) || ss.insertSheet(CONFIG.OUTPUT_SHEET);
  sh.clear().setFrozenRows(2);
  
  sh.getCharts().forEach(chart => sh.removeChart(chart));

  sh.getRange(1,1,1,12).merge()
    .setValue('📉 ОТКАЗЫ (AMO) — только статус «Закрыто и не реализовано»')
    .setBackground('#4285F4').setFontColor('white').setFontWeight('bold').setFontSize(14).setHorizontalAlignment('center');

  sh.getRange(2,1,1,4).setValues([
    ['Сформировано', new Date(), 'Всего отказов', total]
  ]).setFontWeight('bold');
  sh.getRange(2,2).setNumberFormat('dd.MM.yyyy HH:mm');

  let r = 4;

  // Таблица причин
  sh.getRange(r,1,1,3).setValues([['#','Причина','Кол-во']]).setFontWeight('bold').setBackground('#f3f3f3'); r++;
  const body = reasonsTable.map((x,i)=>[i+1, x.reason, x.count]);
  if (body.length) sh.getRange(r,1,body.length,3).setValues(body);
  
  // Редактируемый график-пирог
  if (body.length > 0) {
    const chart = createEditablePieChart_(sh, r, body.length);
    sh.insertChart(chart);
  }

  r += Math.max(15, body.length) + 2;

  // Динамика по месяцам (общая)
  sh.getRange(r,1,1,3).merge().setValue('Общая динамика отказов по месяцам').setBackground('#FFF4C2').setFontWeight('bold'); r++;
  const mRows = Object.entries(monthly).sort((a,b)=>a[0].localeCompare(b[0]));
  if (mRows.length){
    sh.getRange(r,1,1,2).setValues([['Месяц','Отказов']]).setFontWeight('bold').setBackground('#f3f3f3'); r++;
    sh.getRange(r,1,mRows.length,2).setValues(mRows);
    r += mRows.length + 2;
  }
  
  // Гистограмма с разбивкой по причинам
  sh.getRange(r,1,1,8).merge().setValue('Динамика ТОП-5 причин по месяцам').setBackground('#FBBC04').setFontWeight('bold'); r++;
  const stackedChart = createStackedColumnChart_(sh, r, monthlyReasons);
  if(stackedChart) sh.insertChart(stackedChart);
  r += 18; // Оставляем место под график

  // Текст GPT
  sh.getRange(r,1,1,8).merge().setValue('Рекомендации (GPT)').setBackground('#E9EEF6').setFontWeight('bold'); r++;
  sh.getRange(r, 1, 1, 8).merge()
    .setValue(gpt || '—')
    .setWrap(true)
    .setVerticalAlignment('top')
    .setBackground('#f8f9fa');
  
  formatSheetColumns_(sh);
}

/* ==================== ДАННЫЕ И ГРАФИКИ ==================== */

function calculateFrequency_(reasons){
  const freqMap = new Map();
  reasons.forEach(r=>{
    const k = normReason_(r);
    if (!k) return;
    freqMap.set(k, (freqMap.get(k)||0)+1);
  });
  return [...freqMap.entries()]
    .sort((a,b)=>b[1]-a[1])
    .map(([reason,count])=>({reason,count}));
}

function calculateMonthlyReasonBreakdown_(items, reasonsTable) {
  const topReasons = reasonsTable.slice(0, CONFIG.TOP_N_FOR_STACKED_CHART).map(x => x.reason);
  const monthlyData = {};

  items.forEach(item => {
    const month = Utilities.formatDate(item.created, CONFIG.TIMEZONE, 'yyyy-MM');
    const reason = normReason_(item.reason);
    
    if (!monthlyData[month]) {
      monthlyData[month] = {};
      topReasons.forEach(tr => monthlyData[month][tr] = 0);
      monthlyData[month]['Прочие'] = 0;
    }
    
    const reasonKey = topReasons.includes(reason) ? reason : 'Прочие';
    monthlyData[month][reasonKey]++;
  });
  return monthlyData;
}

function createEditablePieChart_(sheet, startDataRow, dataLength) {
  const numRows = Math.min(10, dataLength);
  const reasonsRange = sheet.getRange(startDataRow, 2, numRows);
  const countsRange = sheet.getRange(startDataRow, 3, numRows);
  return sheet.newChart()
    .asPieChart()
    .addRange(countsRange).addRange(reasonsRange)
    .setMergeStrategy(Charts.ChartMergeStrategy.MERGE_COLUMNS)
    .setOption('title', 'ТОП-10 причин отказа')
    .setOption('is3D', true)
    .setOption('legend', { position: 'right' })
    .setPosition(4, 5, 0, 0)
    .build();
}

function createStackedColumnChart_(sheet, startChartRow, monthlyReasons) {
  const months = Object.keys(monthlyReasons).sort();
  if (months.length === 0) return null;

  const reasons = Object.keys(monthlyReasons[months[0]]);
  
  const chartData = [ ['Месяц', ...reasons] ];
  months.forEach(month => {
    const row = [month, ...reasons.map(r => monthlyReasons[month][r] || 0)];
    chartData.push(row);
  });
  
  const dataSourceRange = sheet.getRange(startChartRow + 1, 1, chartData.length, chartData[0].length);
  dataSourceRange.setValues(chartData);
  sheet.hideRows(startChartRow + 1, chartData.length);

  return sheet.newChart()
    .asColumnChart()
    .addRange(dataSourceRange)
    .setMergeStrategy(Charts.ChartMergeStrategy.MERGE_COLUMNS)
    .setStacked()
    .setOption('title', 'Динамика ТОП причин по месяцам')
    .setOption('legend', { position: 'top', maxLines: 3 })
    .setOption('hAxis', { title: 'Месяц' })
    .setOption('vAxis', { title: 'Количество отказов' })
    .setPosition(startChartRow, 1, 0, 0)
    .build();
}

/* ==================== ФОРМАТИРОВАНИЕ ==================== */

function formatSheetColumns_(sh) {
  sh.setColumnWidth(1, CONFIG.COLUMN_WIDTHS.A);
  sh.setColumnWidth(2, CONFIG.COLUMN_WIDTHS.B);
  sh.getRange('B:B').setWrap(true);
  sh.setColumnWidth(3, CONFIG.COLUMN_WIDTHS.C);
  sh.getRange('A:A').setHorizontalAlignment('center');
  sh.getRange('C:C').setHorizontalAlignment('center');
  sh.getRange(1, 1, sh.getMaxRows(), sh.getMaxColumns()).setFontFamily('Arial');
}

/* ==================== ЧТЕНИЕ И ПОИСК КОЛОНОК ==================== */

function readTable_(sh){
  const vals = sh.getDataRange().getValues();
  if (!vals.length) return {header:[],rows:[]};
  const headerRow = (vals[1] && vals[1].some(v=>String(v).trim()!=='')) ? 1 : 0;
  const header = (vals[headerRow]||[]).map(String);
  const rows    = vals.slice(headerRow+1).filter(r=>r.some(x=>String(x).trim()!==''));
  return {header, rows};
}

function detectAmoIndexes_(header){
  const H = header.map(h=>norm_(h));
  const find = (alts)=> H.findIndex(h => alts.map(norm_).some(w => h===w || h.includes(w)));
  return {
    status:  find(['статус','сделка.статус']),
    reason:  find(['причина отказа (об)','причина отказа']),
    created: find(['дата создания','date'])
  };
}

function assertIndexes_(idx, keys){
  const miss = keys.filter(k => idx[k]==null || idx[k]<0);
  if (miss.length){
    const dbg = Object.entries(idx).map(([k,v])=>`${k}:${v}`).join(', ');
    throw new Error('Не найдены колонки: '+miss.join(', ')+' | Найдено: '+dbg);
  }
}

/* ==================== ПОДСЧЁТЫ ==================== */

function calculateMonthlyBreakdown_(items){
  const monthly = {};
  items.forEach(x=>{
    const d = x.created instanceof Date ? x.created : toDate_(x.created);
    if (!d) return;
    const ym = Utilities.formatDate(d, CONFIG.TIMEZONE, 'yyyy-MM');
    monthly[ym] = (monthly[ym]||0)+1;
  });
  return monthly;
}

function compactReasons_(reasons){
  const freq = new Map();
  reasons.forEach(r=>{
    const k = normReason_(r);
    if (!k) return;
    freq.set(k, (freq.get(k)||0)+1);
  });
  const top = [...freq.entries()].sort((a,b)=>b[1]-a[1]).slice(0, CONFIG.MAX_REASON_CLUSTERS);
  const exMap = new Map();
  top.forEach(([k])=>exMap.set(k, []));
  for (const r of reasons){
    const k = normReason_(r);
    if (!exMap.has(k)) continue;
    const arr = exMap.get(k);
    if (arr.length < CONFIG.MAX_EXAMPLES_PER_CAUSE) arr.push(r);
  }
  return top.map(([k,count])=>({reason:k, count, examples: exMap.get(k)||[]}));
}

/* ==================== GPT ==================== */

function callGPT_(apiKey, prompt, model){
  const url = 'https://api.openai.com/v1/chat/completions';
  const payload = {
    model: model || CONFIG.GPT_PRIMARY_MODEL,
    temperature: 0.3,
    max_tokens: 2000,
    messages: [
      {role:'system', content:'Ты — ведущий аналитик по продажам, который пишет подробные, структурированные и глубокие отчёты.'},
      {role:'user', content: prompt}
    ]
  };
  const resp = UrlFetchApp.fetch(url, {
    method:'post', contentType:'application/json', payload: JSON.stringify(payload),
    headers: { Authorization: `Bearer ${apiKey}` }, muteHttpExceptions:true
  });
  if (resp.getResponseCode()>=300){
    throw new Error('OpenAI Ошибка '+resp.getResponseCode()+': '+resp.getContentText());
  }
  const data = JSON.parse(resp.getContentText());
  return data?.choices?.[0]?.message?.content?.trim() || '—';
}

function buildDetailedAnalysisPrompt_(compact,total){
  const lines = compact.map(c=>{
    const ex = c.examples?.length ? ` | Примеры: «${c.examples.join('», «')}»` : '';
    return `• ${c.reason} — ${c.count}${ex}`;
  }).join('\n');
  return (
`Ты — ведущий аналитик продаж. Даны агрегированные причины отказов из CRM
(фильтр статуса: «Закрыто и не реализовано»). Всего отказов: ${total}.
ЗАДАЧА:
1) Сгруппируй причины в 5–8 смысловых кластеров.
2) Для каждого кластера: краткий анализ сути, вероятные корневые причины (2–3),
   и конкретные действия (3–5): скрипты/процессы/SLA, обучение, оффер/цены, скорость реакции, трафик/UTM.
3) Заверши блоком «Быстрые победы» с 4–6 пунктами.
Исходные данные:
${lines}`
  );
}

/* ==================== HTML-ПИСЬМО ==================== */

function createPieChartImage_(reasonsData){
  const dataTable = Charts.newDataTable()
    .addColumn(Charts.ColumnType.STRING, 'Причина')
    .addColumn(Charts.ColumnType.NUMBER, 'Кол-во');
  const top9 = reasonsData.slice(0,9);
  const other = reasonsData.slice(9).reduce((s,x)=>s+x.count,0);
  top9.forEach(x=>dataTable.addRow([x.reason, x.count]));
  if (other>0) dataTable.addRow(['Прочие', other]);
  const chart = Charts.newPieChart()
    .setDataTable(dataTable)
    .setOption('is3D', true)
    .setOption('legend', { position: 'right', textStyle: { fontSize: 12 } })
    .setOption('chartArea', {left: 20, top: 20, width: '100%', height: '90%'})
    .setDimensions(800, 500)
    .build();
  return chart.getBlob();
}

function formatReportAsHtml_(subject, gptText, monthlyData, chartCid){
  const gptHtml = markdownToHtml_(gptText);
  const monthlyHtml = formatMonthlyDataAsHtml_(monthlyData);
  return `
  <div style="font-family: Arial, sans-serif; line-height:1.6; color:#333; max-width:860px; margin:20px auto; padding:24px; border:1px solid #e5e5e5; border-radius:10px;">
    <h1 style="color:#1a73e8; border-bottom:2px solid #1a73e8; padding-bottom:10px; margin:0 0 16px;">${subject}</h1>
    <h2 style="margin-top:18px;">ТОП причин отказа (диаграмма)</h2>
    <div style="text-align:center; margin:10px 0 20px;">
      <img src="cid:${chartCid}" alt="Pie chart" style="max-width:100%; height:auto;">
    </div>
    <h2>Динамика отказов по месяцам</h2>
    ${monthlyHtml}
    <h2>Детальный разбор от GPT</h2>
    <div style="background:#f8f9fa; padding:16px; border-radius:8px; white-space:pre-wrap;">${gptHtml}</div>
    <p style="text-align:center; color:#999; font-size:12px; margin-top:24px;">Отчёт сформирован автоматически.</p>
  </div>`;
}

function markdownToHtml_(text){
  if (!text) return '';
  return text
    .replace(/\*\*(.*?)\*\*/g, '<b>$1</b>')
    .replace(/^\s*[-*•]\s+(.*)$/gm, '<li>$1</li>')
    .replace(/(<li>.*<\/li>)/gs, '<ul>$1</ul>')
    .replace(/\n/g, '<br>');
}

function formatMonthlyDataAsHtml_(monthly){
  const entries = Object.entries(monthly).sort((a,b)=>a[0].localeCompare(b[0]));
  if (!entries.length) return '<p>Нет данных.</p>';
  const rows = entries.map(([m,c])=>`<tr><td style="padding:6px 10px;border:1px solid #eee;">${m}</td><td style="padding:6px 10px;border:1px solid #eee;">${c}</td></tr>`).join('');
  return `<table style="border-collapse:collapse; border:1px solid #eee; margin:8px 0;">
    <thead><tr><th style="padding:6px 10px;border:1px solid #eee;background:#fafafa;">Месяц</th><th style="padding:6px 10px;border:1px solid #eee;background:#fafafa;">Отказов</th></tr></thead>
    <tbody>${rows}</tbody>
  </table>`;
}

/* ==================== УТИЛИТЫ ==================== */

function toDate_(v){ if (v instanceof Date) return v; if(!v) return null; const d=new Date(v); return isNaN(d)?null:d; }
function str(v){ return String(v==null?'':v).trim(); }
function norm_(s){ return String(s||'').toLowerCase().replace(/[₽,.;:()\-–—]/g,' ').replace(/\s+/g,' ').trim(); }
function normReason_(s){ return String(s||'').toLowerCase().replace(/\s+/g,' ').trim(); }
function isClosedLost_(status){ return /закрыт.*не.*реализ/i.test(String(status||'')); }
